##NPM2

如果App有两个模块A与C，分别依赖B-v1.0版本与B-v2.0版本。你可以输入**npm ls**来展示依赖清单来查看他们的关系。

###App

```
---	A@1.0
	---B@1.0
---C@1.0
	---B@2.0
```		
如果只想查看主要的依赖，你可以输入**npm ls --depth=0**
```
---A@1.0
---C@1.0
```

然而，nodejs做的还不够。尽管他们嵌套关系允许同一个包两个版本共存，但大多数包加载器不允许两个版本同时出现在内存中。幸运的是，nodejs模包加载器的作者编写处理了这种情况，能轻松的读取多个包并且没有冲突。

npm与node包加载器如何良好的共存？他们均由同一个人编写比较大的部分。作者Isaac Z. Schlueter。npm与node加载器像一张纸的两面，特别适合管理运行时的nodejs依赖关系。

##NPM3
npm3处理依赖关系与npm2不同。

npm2使用嵌套关系来安装依赖。npm3试图减轻嵌套现状，npm3尝试安装相同的依赖通过扁平的层级结构。同级是主要的依赖，嵌套是不同的依赖。

- 目录结构位置不在检测类型（主要的、次要的、bugs）
- 依赖处理取决于安装顺序，顺序安装会改变node_module目录结构

如果App有两个模块A与C，分别依赖B-v1.0版本与B-v2.0版本。你可以输入**npm ls**来展示依赖清单来查看他们的关系。

###App

```
---A@1.0
---B@1.0
---C@1.0
	---B@2.0
```		
如果你改变安装顺序，先安装C模块，再安装A模块，则关系如下：
###App

```
---C@1.0
---B@2.0
---A@1.0
	---B@1.0
```		


如果只想查看主要的依赖，你可以输入**npm ls --depth=0**
```
---A@1.0
---C@1.0
```
